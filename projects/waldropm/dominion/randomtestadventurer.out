Testing adventurerRefactor() by using a random tester.
RANDOM TESTS.
Finished 500 tests.
Finished 1000 tests.
Finished 1500 tests.
Finished 2000 tests.
ALL TESTS OK
File 'randomtestadventurer.c'
Lines executed:90.14% of 71
Branches executed:96.15% of 52
Taken at least once:65.38% of 52
Calls executed:75.86% of 29
Creating 'randomtestadventurer.c.gcov'

        -:    0:Source:randomtestadventurer.c
        -:    0:Graph:randomtestadventurer.gcno
        -:    0:Data:randomtestadventurer.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* -----------------------------------------------------------------------
        -:    2: *  Test adventurerRefactor() by using a random tester.
        -:    3: *  Include the following lines in your makefile:
        -:    4: *
        -:    5: *  randomtestadventurer: randomtestadventurer.c dominion.o rngs.o
        -:    6: *	gcc -o randomtestadventurer -g  randomtestadventurer.c dominion.o rngs.o $(CFLAGS)
        -:    7: *
        -:    8: * type "./randomtestadventurer" to run
        -:    9: * -----------------------------------------------------------------------
        -:   10: */
        -:   11:
        -:   12:#include "dominion.h"
        -:   13:#include "dominion_helpers.h"
        -:   14:#include <string.h>
        -:   15:#include <stdio.h>
        -:   16:#include <assert.h>
        -:   17:#include "rngs.h"
        -:   18:#include <math.h>
        -:   19:#include <stdlib.h>
        -:   20:
        -:   21:// find a target card in the hand
function findCardInHand called 2000 returned 100% blocks executed 86%
     2000:   22:int findCardInHand(int player, struct gameState *state, int card) {
        -:   23:    int i;
   487376:   24:    for (i = 0; i < state->deckCount[player]; i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
   485376:   25:        if(card == state->deck[player][i]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   26:            return i;
        -:   27:        }
        -:   28:    }
     2000:   29:    return -1;
        -:   30:}
        -:   31:
function countHandTreasure called 4000 returned 100% blocks executed 100%
     4000:   32:int countHandTreasure(int player, struct gameState *state){
     4000:   33:    int i, card, count = 0;
   997720:   34:    for(i = 0; i < state->handCount[player]; i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
   993720:   35:        card = state->hand[player][i];
   993720:   36:        if (card == copper || card == silver || card == gold){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 1% (fallthrough)
branch  5 taken 99%
     4000:   37:            count++;
        -:   38:        }
        -:   39:    }
     4000:   40:    return count;
        -:   41:}
        -:   42:
function countDeckTreasure called 6000 returned 100% blocks executed 100%
     6000:   43:int countDeckTreasure(int player, struct gameState *state){
     6000:   44:    int i, card, count = 0;
  1466128:   45:    for(i = 0; i < state->deckCount[player]; i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
  1460128:   46:        card = state->deck[player][i];
  1460128:   47:        if (card == copper || card == silver || card == gold){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 1% (fallthrough)
branch  5 taken 99%
     4000:   48:            count++;
        -:   49:        }
        -:   50:    }
     6000:   51:    return count;
        -:   52:}
        -:   53:
function countDiscardTreasure called 4000 returned 100% blocks executed 89%
     4000:   54:int countDiscardTreasure(int player, struct gameState *state){
     4000:   55:    int i, card, count = 0;
  1017806:   56:    for(i = 0; i < state->discardCount[player]; i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
  1013806:   57:        card = state->discard[player][i];
  1013806:   58:        if (card == copper || card == silver || card == gold){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:   59:            count++;
        -:   60:        }
        -:   61:    }
     4000:   62:    return count;
        -:   63:}
        -:   64:
function printHand called 0 returned 0% blocks executed 0%
    #####:   65:void printHand(int player, struct gameState *state){
        -:   66:    int i, card;
        -:   67:    
    #####:   68:    for(i = 0; i < state->handCount[player]; i++){
branch  0 never executed
branch  1 never executed
    #####:   69:        card = state->hand[player][i];
    #####:   70:        printf("++++Test player %d has %dth card(s) %d in hand.\n", player, i, card);
call    0 never executed
        -:   71:    }
    #####:   72:}
        -:   73:
function checkAdventurerRefactor called 2000 returned 100% blocks executed 78%
     2000:   74:int checkAdventurerRefactor(int player, struct gameState *post) {
        -:   75:    struct gameState pre;
        -:   76:    int r, handPos;
        -:   77:
        -:   78:    int temphand[MAX_HAND];// moved above the if statement
     2000:   79:    int drawntreasure = 0;
        -:   80:    int cardDrawn;
     2000:   81:    int z = 0;// this is the counter for the temp hand
        -:   82:
     2000:   83:    handPos = findCardInHand(player, post, adventurer);
call    0 returned 100%
     2000:   84:    if(handPos < 0){ // if did not have a smithy card, then get one
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2000:   85:        post->hand[player][post->handCount[player]] = adventurer; // player gets the adventurer card
     2000:   86:        post->handCount[player]++;
     2000:   87:        handPos = post->handCount[player] - 1; // record the adventurer card position
        -:   88:    }
        -:   89:
     2000:   90:    if(countDeckTreasure(player, post) < 2){// make sure the deck has at least two treasure cards
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     2000:   91:            post->deck[player][post->deckCount[player]] = gold;
     2000:   92:            post->deckCount[player]++;
     2000:   93:            post->deck[player][post->deckCount[player]] = gold;
     2000:   94:            post->deckCount[player]++;
        -:   95:    }
        -:   96:
     2000:   97:    memcpy (&pre, post, sizeof(struct gameState)); // copy from post to pre
        -:   98:
     2000:   99:    r = adventurerRefactor(&drawntreasure, post, &player, &cardDrawn, temphand, &z); // play the adventurer card
call    0 returned 100%
        -:  100:
     2000:  101:    assert (r == 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     2000:  102:    assert(countHandTreasure(player, &pre) + 2 == countHandTreasure(player, post)); // get 2 new treasure cards in hand now.
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
     2000:  103:    assert(countDeckTreasure(player, &pre) - 2 == countDeckTreasure(player, post)); // deck lost 2 treasure cards now.
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
     2000:  104:    assert(countDiscardTreasure(player, &pre) == countDiscardTreasure(player, post)); // discard's treasure cards does not change.
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
     2000:  105:    assert(pre.handCount[player] + 2 == post->handCount[player]); // get 2 new cards in hand now.
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     2000:  106:    assert(pre.discardCount[player]+ (pre.deckCount[player] - post->deckCount[player] - 2) == post->discardCount[player]); // the drawn non treasure cards from deck should go to discard
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  107:
     2000:  108:    return 0;
        -:  109:}
        -:  110:
function main called 1 returned 100% blocks executed 100%
        1:  111:int main(int argc, char *argv[]){
        -:  112:    int i, n, p;
        -:  113:
        -:  114:    struct gameState G;
        -:  115:
        1:  116:    printf ("Testing adventurerRefactor() by using a random tester.\n");
call    0 returned 100%
        -:  117:
        1:  118:    printf ("RANDOM TESTS.\n");
call    0 returned 100%
        -:  119:
        1:  120:    SelectStream(2);
call    0 returned 100%
        1:  121:    PutSeed(3);
call    0 returned 100%
        -:  122:
     2001:  123:    for (n = 0; n < 2000; n++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
 52602000:  124:        for (i = 0; i < sizeof(struct gameState); i++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
 52600000:  125:            ((char*)&G)[i] = floor(Random() * 256);
call    0 returned 100%
        -:  126:        }
     2000:  127:        p = floor(Random() * 2);
call    0 returned 100%
     2000:  128:        G.deckCount[p] = floor(Random() * MAX_DECK);
call    0 returned 100%
     2000:  129:        G.discardCount[p] = 3 + floor(Random() * MAX_DECK);
call    0 returned 100%
     2000:  130:        G.handCount[p] = floor(Random() * MAX_HAND);
call    0 returned 100%
     2000:  131:        G.playedCardCount = floor(Random() * MAX_HAND);
call    0 returned 100%
        -:  132:
     2000:  133:        checkAdventurerRefactor(p, &G);
call    0 returned 100%
        -:  134:        
     2000:  135:        if((n + 1) % 500 == 0){
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        4:  136:            printf ("Finished %d tests.\n", n + 1);
call    0 returned 100%
        -:  137:        }
        -:  138:    }
        -:  139:
        1:  140:    printf ("ALL TESTS OK\n");
call    0 returned 100%
        1:  141:    return 0;
        -:  142:}
        -:  143:
