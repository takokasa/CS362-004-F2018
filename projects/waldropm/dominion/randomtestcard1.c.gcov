        -:    0:Source:randomtestcard1.c
        -:    0:Graph:randomtestcard1.gcno
        -:    0:Data:randomtestcard1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* -----------------------------------------------------------------------
        -:    2: *  Test smithyRefactor() by using a random tester.
        -:    3: *  Include the following lines in your makefile:
        -:    4: *
        -:    5: *  randomtestcard1: randomtestcard1.c dominion.o rngs.o
        -:    6: *	gcc -o randomtestcard1 -g  randomtestcard1.c dominion.o rngs.o $(CFLAGS)
        -:    7: *
        -:    8: * type "./randomtestcard1" to run
        -:    9: * -----------------------------------------------------------------------
        -:   10: */
        -:   11:
        -:   12:#include "dominion.h"
        -:   13:#include "dominion_helpers.h"
        -:   14:#include <string.h>
        -:   15:#include <stdio.h>
        -:   16:#include <assert.h>
        -:   17:#include "rngs.h"
        -:   18:#include <math.h>
        -:   19:#include <stdlib.h>
        -:   20:
        -:   21:// find a target card in the hand
function findCardInHand called 2000 returned 100% blocks executed 86%
     2000:   22:int findCardInHand(int player, struct gameState *state, int card) {
        -:   23:    int i;
   497989:   24:    for (i = 0; i < state->deckCount[player]; i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
   495989:   25:        if(card == state->deck[player][i]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   26:            return i;
        -:   27:        }
        -:   28:    }
     2000:   29:    return -1;
        -:   30:}
        -:   31:
function checkSmithyRefactor called 2000 returned 100% blocks executed 74%
     2000:   32:int checkSmithyRefactor(int player, struct gameState *post) {
        -:   33:    struct gameState pre;
        -:   34:    int r, handPos;
        -:   35:
     2000:   36:    handPos = findCardInHand(player, post, smithy);
call    0 returned 100%
     2000:   37:    if(handPos < 0){ // if did not have a smithy card, then get one
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2000:   38:        post->hand[player][post->handCount[player]] = smithy; // player gets the smithy card
     2000:   39:        post->handCount[player]++;
     2000:   40:        handPos = post->handCount[player] - 1; // record the smithy card position
        -:   41:    }
     2000:   42:    memcpy (&pre, post, sizeof(struct gameState)); // copy from post to pre
        -:   43:
     2000:   44:    r = smithyRefactor (&player, post, &handPos); // play the smithy card
call    0 returned 100%
        -:   45:
     2000:   46:    pre.handCount[player] += 2; // get 3 new cards and played smithy card, so user has 3 - 1 = 2 more cards in hand now.
        -:   47:
     2000:   48:    if(pre.deckCount[player] <= 2){ // if there are not enough cards in deck, pull all the cards to discard pile. 
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        9:   49:        pre.deckCount[player] = pre.discardCount[player] + pre.deckCount[player] - 3;
        9:   50:        pre.discardCount[player] = 0;
        -:   51:    }else{
     1991:   52:        pre.deckCount[player] -= 3; // deck lost 3 card now.
        -:   53:    }
        -:   54:    
     2000:   55:    pre.playedCardCount++; // smithy card goes to playcards.
        -:   56:    
     2000:   57:    assert (r == 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     2000:   58:    assert(pre.handCount[player] == post->handCount[player]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     2000:   59:    assert(pre.deckCount[player] == post->deckCount[player]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     2000:   60:    assert(pre.discardCount[player] == post->discardCount[player]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     2000:   61:    assert(pre.playedCardCount == post->playedCardCount);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     2000:   62:    return 0;
        -:   63:}
        -:   64:
        -:   65:
function main called 1 returned 100% blocks executed 100%
        1:   66:int main(int argc, char *argv[]){
        -:   67:    int i, n, p;
        -:   68:
        -:   69:    struct gameState G;
        -:   70:
        1:   71:    printf ("Testing smithyRefactor() with a random tester.\n");
call    0 returned 100%
        -:   72:
        1:   73:    printf ("RANDOM TESTS.\n");
call    0 returned 100%
        -:   74:
        1:   75:    SelectStream(2);
call    0 returned 100%
        1:   76:    PutSeed(3);
call    0 returned 100%
        -:   77:
     2001:   78:    for (n = 0; n < 2000; n++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
 52602000:   79:        for (i = 0; i < sizeof(struct gameState); i++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
 52600000:   80:            ((char*)&G)[i] = floor(Random() * 256);
call    0 returned 100%
        -:   81:        }
     2000:   82:        p = floor(Random() * 2);
call    0 returned 100%
     2000:   83:        G.deckCount[p] = floor(Random() * MAX_DECK);
call    0 returned 100%
     2000:   84:        G.discardCount[p] = 3 + floor(Random() * MAX_DECK);
call    0 returned 100%
     2000:   85:        G.handCount[p] = floor(Random() * MAX_HAND);
call    0 returned 100%
     2000:   86:        G.playedCardCount = floor(Random() * MAX_HAND);
call    0 returned 100%
        -:   87:
     2000:   88:        checkSmithyRefactor(p, &G);
call    0 returned 100%
        -:   89:
     2000:   90:        if((n + 1) % 500 == 0){
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        4:   91:            printf ("Finished %d tests.\n", n + 1);
call    0 returned 100%
        -:   92:        }
        -:   93:    }
        -:   94:
        1:   95:    printf ("ALL TESTS OK\n");
call    0 returned 100%
        1:   96:    return 0;
        -:   97:}
        -:   98:
